import { createContext, useState } from "react"
import axios from 'axios';
import { useEffect } from "react";
const pako = require('pako');
const { XMLParser} = require("../../node_modules/fast-xml-parser/src/fxp");

const AppContext = createContext()

const AppContextProvider = (props) => {
    const [build, setBuild] = useState(null);
    const [isLoading,setIsLoading] = useState(false);
    const [slots,setSlots] = useState(null);
    const [prices, setPrices] = useState(null);
    const [gems,setGems] = useState(null);
    const [items,setItems] = useState(null);
    const [gemByLevel,setGemByLevel] = useState(null);
    const [currentClass,setCurrentClass] = useState(null);
    const [currentAscend,setCurrentAscend] = useState(null);
    const [currentMainSkill,setCurrentMainSkill] = useState(null);
    const [currentMainSkillImg,setCurrentMainSkillImg] = useState(null);
    const [currentNotes,setCurrentNotes] = useState(null);
    const [currentSkillTree,setCurrentSkillTree] = useState([]);
    const [localBuild,setLocalBuild] = useState([]);
    const [currentLevel,setCurrentLevel] = useState(null);
    const [currentMainSocketGroup,setCurrentMainSocketGroup] = useState(null);
    const [headerVisible,setHeaderVisible] = useState(true);

    useEffect(() => {
        setIsLoading(true);
        getGemsApi();
        getPriceApi();
        loadBuildFromLocal();        
    },[]);
    
    /**
     * It takes a pastebin link, sanitizes it, and then sends it to the backend to be processed.
     * @param pastebinLink - The pastebin link you want to get the code from.
     */
    const getPastebin = (pastebinLink) => {
        setIsLoading(true);
        let sanitizeUrl = pastebinLink;
        if(sanitizeUrl.indexOf("/raw/") === -1) {
            sanitizeUrl = sanitizeUrl.replace("https://pastebin.com/","https://pastebin.com/raw/")
        }
        axios.post(process.env.REACT_APP_API+'/api/pastebin',sanitizeUrl)
        .then(function (response) {
            // handle success
            getPobCode(response.data);
            setIsLoading(false);
        })
        .catch(function (error) {
            // handle error
            console.log(error);
            setIsLoading(false);
        })
    }

    /**
     * It makes a GET request to the API, and if it's successful, it sets the prices state to the
     * response data, and sets the isLoading state to false.
     */
    const getPriceApi = () => {
        axios.get(process.env.REACT_APP_API+'/api/price')
        .then(function (response) {
            // handle success
            setPrices(response.data);
            setIsLoading(false);
        })
        .catch(function (error) {
            // handle error
            console.log(error);
            setIsLoading(false);
        })
    }

    /**
     * It makes a GET request to the API, and if it's successful, it sets the state of the gems
     * variable to the response data, and sets the isLoading state to false.
     */
    const getGemsApi = () => {
        axios.get(process.env.REACT_APP_API+'/api/gems')
        .then(function (response) {
            // handle success
            setGems(response.data);
            setIsLoading(false);
        })
        .catch(function (error) {
            // handle error
            console.log(error);
            setIsLoading(false);
        })
    }

    /**
     * It takes a string, replaces some characters, converts it to base64, then decompresses it.
     * The string is a POB code, which is a compressed version of a character's build.
     * @param pobCode - the code that is generated by PoB.
     */
    const getPobCode = (pobCode) => {
        // when we change build, we reset all state
        setSlots(null);
        setItems(null);
        setGemByLevel(null);
        setCurrentClass(null);
        setCurrentAscend(null);
        setCurrentMainSkill(null);
        setCurrentMainSkillImg(null);
        setCurrentNotes(null);
        setCurrentSkillTree([]);
        setCurrentLevel(null);
        setCurrentMainSocketGroup(null);

        // magic happen here 
        let extractString =  pobCode.replace(/_/g,"/").replace(/-/g,"+");
        var b64Data     = extractString;
        // Decode base64 (convert ascii to binary)
        var strData     = atob(b64Data);
        // Convert binary string to character-number array
        var charData    = strData.split('').map(function(x){return x.charCodeAt(0);});
        // Turn number array into byte-array
        var binData     = new Uint8Array(charData);
        // Pako magic
        var data        = pako.inflate(binData);
        var xmlData = new Uint8Array(data).reduce(function (data, byte) {
            return data + String.fromCharCode(byte);
          }, '');
        
        const parser = new XMLParser({
            ignoreAttributes: false,
            attributeNamePrefix : "_",
            allowBooleanAttributes: true
        });
        let jObj = parser.parse(xmlData);
        setBuild(jObj)
        analyseXml(jObj,pobCode);      
          
    }

    /**
     * It takes a POB code, parses it, and then adds the build to local storage
     * @param _build - the xml object
     * @param pobCode - the pob code
     */
    const analyseXml =  (_build,pobCode) => {
        let skills = null;
        let tempGemByLevel = [];
        let myMainSocketGroup = _build.PathOfBuilding.Build._mainSocketGroup;
        
        /* SKILLS STUFF , depending of the pob you can have SkillSet or not */
        if(_build.PathOfBuilding.Skills.Skill !== undefined) {
            skills = _build.PathOfBuilding.Skills.Skill
        } else {
            skills = [];
            // SkillSet can contain array Or object we need to check it
            if (Array.isArray(_build.PathOfBuilding.Skills.SkillSet)) {
                _build.PathOfBuilding.Skills.SkillSet.forEach(skillSet => {
                    skillSet.Skill.forEach(skill => {
                        skills.push(skill);
                    });
                })
            } else {
                _build.PathOfBuilding.Skills.SkillSet.Skill.forEach(skill => {
                    skills.push(skill);
                })
            }
            
        }

        setSlots(skills);
        let varCurrentMainSkill = null;
        skills.forEach(function(element,i){
            if(Array.isArray(element.Gem)) {
                element.Gem.forEach(function(gem){
                    // We have already add this gems, we just add +1 to number
                    if(tempGemByLevel.find((g) => g._skillId === gem._skillId) !== undefined) {
                        let index = tempGemByLevel.findIndex((g) => g._skillId === gem._skillId);
                        if(tempGemByLevel[index].number === undefined) {
                            tempGemByLevel[index].number = 1;
                        } else {
                            tempGemByLevel[index].number++;
                        }
                    } else {
                        tempGemByLevel.push(hydrateGem(gem));
                    }
                })
            } else {
                if(element.Gem !== undefined) {
                    if(tempGemByLevel.find((g) => g._skillId === element.Gem._skillId) !== undefined) {
                        let index = tempGemByLevel.findIndex((g) => g._skillId === element.Gem._skillId);
                        if(tempGemByLevel[index].number === undefined) {
                            tempGemByLevel[index].number = 1;
                        } else {
                            tempGemByLevel[index].number++;
                        }
                    } else {
                        tempGemByLevel.push(hydrateGem(element.Gem));
                    }
                }                
            }   
            // FOR BUILD HEADER 
            if(i+1 === parseInt(myMainSocketGroup)) {
                if(element.Gem !== undefined) {
                    let tempGemName = element.Gem.find((e) => e._nameSpec.indexOf("Support") === -1)
                    setCurrentMainSkill(tempGemName._nameSpec)
                    varCurrentMainSkill = tempGemName._nameSpec;
                    let gemsData = gems.find((g) => g.name === tempGemName._nameSpec)
                    if(gemsData !== undefined) {
                        setCurrentMainSkillImg(gemsData.icon_path);
                    } else {
                        console.log("Didn't find "+tempGemName._nameSpec,tempGemName);
                    }
                }
            }
        })
        
        getGemsByLevel(tempGemByLevel);
        
        setCurrentClass(_build.PathOfBuilding.Build._className)
        setCurrentAscend(_build.PathOfBuilding.Build._ascendClassName);
        setCurrentLevel(_build.PathOfBuilding.Build._level);
        setCurrentMainSocketGroup(_build.PathOfBuilding.Build._mainSocketGroup)
        setCurrentNotes(_build.PathOfBuilding.Notes);
        
        /* ITEMS STUFF */
        let tabItem = [];
        let totalChaos = 0;
        let totalExalted = 0;
        let totalChaosHc = 0;
        let totalExaltedHc = 0;
        _build.PathOfBuilding.Items.Item.forEach(function(item) {
            let data = item['#text'];
            let tabData = data.split('\n');
            let levelReq = tabData.filter((e) => e.indexOf("LevelReq") > -1);
            if(levelReq.length > 0) {
                levelReq = levelReq[0].split(':')[1].trim();
            } else {
                levelReq = 0;
            }

            if (tabData[0].indexOf("UNIQUE") > 0) {
                if(tabItem.find((i) => i.name === tabData[1]) === undefined) {
                    let price = Object.entries(prices.normal).filter((pr,i) => {
                        if(pr[0] === tabData[1].replace("'","")) {
                            return true
                        }        
                        return false;
                    })
                    let priceHard = Object.entries(prices.hardcore).filter((pr,i) => {
                        if(pr[0] === tabData[1].replace("'","")) {
                            return true
                        }        
                        return false;
                    })

                    // we build the Item object
                    let priceDisplayHc = 0;
                    let priceDisplay = 0;
                    let icon = null;
                    let totalChange = 0;
                    if(price[0] !== undefined && price[0][1] !== undefined) {
                        totalChange = price[0][1].totalChange
                        priceDisplay = {"chaosValue": price[0][1].chaosValue,"exaltedValue" : price[0][1].exaltedValue,"totalChange":totalChange}
                        totalChaos += price[0][1].chaosValue
                        totalExalted += price[0][1].exaltedValue
                        icon = price[0][1].icon
                        totalChange = price[0][1].totalChange
                    }
                    if(priceHard[0] !== undefined && priceHard[0][1] !== undefined) {
                        totalChange = priceHard[0][1].totalChange
                        priceDisplayHc = {"chaosValue": priceHard[0][1].chaosValue,"exaltedValue" : priceHard[0][1].exaltedValue,"totalChange":totalChange}
                        totalChaosHc += priceHard[0][1].chaosValue
                        totalExaltedHc += priceHard[0][1].exaltedValue
                        icon = priceHard[0][1].icon
                        
                    }
                    
                    tabItem.push({"name":tabData[1],"icon": icon,"base": tabData[2],"levelReq": levelReq,"price" : priceDisplay,"priceHc": priceDisplayHc});
                }
            }
        })
        
        setItems({"totalChaos":totalChaos,"totalExalted": totalExalted,"totalChaosHc":totalChaosHc,"totalExaltedHc":totalExaltedHc,"items" :tabItem});

        /* SKILL TREE STUFF */
        let tabSkillTree = [];
        if(Array.isArray(_build.PathOfBuilding.Tree.Spec)) {
            _build.PathOfBuilding.Tree.Spec.forEach((spec) => {
                let treeObject = {
                    "url" : spec.URL,
                    "title": spec._title,
                    "treeVersion": spec._treeVersion,
                    "node": getNodeTree(_build)
                }
                tabSkillTree.push(treeObject);
            })
        } else {
            let spec = _build.PathOfBuilding.Tree.Spec;
            let treeObject = {
                "url" : spec.URL,
                "title": spec._title,
                "treeVersion": spec._treeVersion,
                "node": getNodeTree(_build)
            }
            tabSkillTree.push(treeObject);
        }
        
        setCurrentSkillTree(tabSkillTree);
        addBuildToLocal(_build.PathOfBuilding.Build._className,_build.PathOfBuilding.Build._ascendClassName,_build.PathOfBuilding.Build._level,varCurrentMainSkill,pobCode);
    }

    /**
     * It takes a build object, checks if the build has multiple specs, and if it does, it loops
     * through each spec and returns the node tree. If it doesn't, it just returns the node tree.
     * @param build - The build object
     * @returns An array of strings.
     */
    const getNodeTree = (build) => {
        let nodeTree = "";
        if(Array.isArray(build.PathOfBuilding.Tree.Spec)) {
            build.PathOfBuilding.Tree.Spec.forEach(function(element){
                nodeTree = element._nodes.split(",");
            })
        }
        else {
            nodeTree = build.PathOfBuilding.Tree.Spec._nodes.split(",");
        }
        return nodeTree;
    }
    
    /**
     * It takes a gem object, searches for the gem in the gem list, and if it finds it, it adds the gem's
     * properties to the gem object.
     * @returns The return value is the _gem object.
     */
    const hydrateGem = ({..._gem}) => {
        let myGem = null;
        let currentName = null;
        if(_gem._gemId !== undefined) {
            if(_gem._gemId.indexOf("Support") > -1){
                // support gem
                myGem = gems.find((currentGem) => currentGem.name === _gem._nameSpec+" Support");
                currentName = _gem._nameSpec+" Support"
            } else {
                myGem = gems.find((currentGem) => currentGem.name === _gem._nameSpec);
                currentName = _gem._nameSpec
            }
            if(myGem !== undefined) {
                _gem._levelReq = myGem.level_req
                _gem._dexReq = myGem.dex_req
                _gem._strReq = myGem.str_req
                _gem._intReq = myGem.int_req
                _gem._nameSpec = currentName;
                _gem._iconPath = myGem.icon_path
                _gem._primaryAtt = myGem.primary_att
                _gem._rewards = myGem.rewards
                _gem._act = myGem.act
            } else {
                console.group("Error Gem");
                console.log("Error with the gem",myGem,_gem);
                console.groupEnd();
            }
        }
        
        return _gem;
    }

    /**
     * It takes an array of objects, sorts them by the levelReq, then creates a new array indexes with this level and put it in the state
     * @param tempGemByLevel - an array of gems
     */
    const getGemsByLevel = (tempGemByLevel) => {
        let tabGem = tempGemByLevel;
        // sort by level
        tabGem.sort(function(a,b){return (a._levelReq < b._levelReq ? -1 : 1)})
        let temp = [];
        // instanciate an array with index = levelReq
        tabGem.forEach((gem,index) => {
            if(temp[gem._levelReq] === undefined) {temp[gem._levelReq] = []}
            temp[gem._levelReq].push(gem);
        })
        setGemByLevel(temp);
    }
    
    /**
     * If localStorage exists, parse the JSON string from localStorage and set the localBuild state to
     * the parsed array.
     */
    const loadBuildFromLocal = () => {
        if (localStorage) {
            let array = JSON.parse(localStorage.getItem("buildLink"));
            if(array !== null) {
                setLocalBuild(array);
            }            
        }
    }


    /**
     * `buf2hex` takes an `ArrayBuffer` and returns a `String` of hexadecimal characters
     * @param buffer - The ArrayBuffer to convert to a hex string.
     * @returns A string of hexadecimal characters.
     */
    const buf2hex = (buffer) => { // buffer is an ArrayBuffer
        return Array.prototype.map.call(new Uint8Array(buffer), x => ('00' + x.toString(16)).slice(-2)).join('');
    }


    /**
     * Takes pob string, converts it to a byte array, then hashes it with SHA-1, then converts the
     * hash to a hex string, then stores it in local storage if not already there.
     * 
     * @param _currentClass - The class of the build (e.g. "Marauder")
     * @param _currentAscend - Ascendancy class
     * @param _currentLevel - The level of the character
     * @param _currentMainSkill - The name of the skill you're using.
     * @param _pobString - The pob string
     */
    const addBuildToLocal = async (_currentClass,_currentAscend,_currentLevel,_currentMainSkill,_pobString) => {
        if (localStorage) {
            var uint8array = await new TextEncoder("utf-8").encode(_pobString);
            let currentHash = await window.crypto.subtle.digest('sha-1', uint8array);
            const str = buf2hex(currentHash);
            if(localBuild.find((e) => e.hash !== undefined && e.hash === str) === undefined) {
                var data = {
                    'buildClass': _currentClass,
                    'ascendClass': _currentAscend,
                    'level': _currentLevel,
                    'mainSkill' : _currentMainSkill,
                    'pobString': _pobString,
                    'hash':  str
                }
                let temp = localBuild
                temp.push(data);
                localStorage.setItem("buildLink", JSON.stringify(temp));
                loadBuildFromLocal();
            }
        }
    }

    return (
        <AppContext.Provider value={{
            getPastebin,
            items,
            getPobCode,
            build,
            slots,
            prices,
            gems,
            gemByLevel,
            currentClass,
            currentAscend,
            currentLevel,
            currentMainSkill,
            currentMainSkillImg,
            currentSkillTree,
            currentMainSocketGroup,
            currentNotes,
            hydrateGem,
            headerVisible,setHeaderVisible,
            setIsLoading,
            isLoading,
            localBuild
            }}>
            { props.children }
        </AppContext.Provider>
    )
}
export { AppContextProvider, AppContext }